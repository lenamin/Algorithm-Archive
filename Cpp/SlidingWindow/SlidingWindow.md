# Sliding Window 

### [과일 탕후루 문제를 통해 익히는 Sliding Window](https://www.acmicpc.net/problem/30804)

#### 어려웠던 점 
- 일단 문제 이해에 어려움을 겪음 → 이는 슬라이딩 윈도우에 익숙하지 않아 생긴 문제로 슬라이딩 윈도우 로직 기본 구현에 집중함 <br>

#### **슬라이딩 윈도우 문제인지 확인하는 방법** 
  - 연속된 구간에 대한 문제인지? (부분배열) 
     : 연속된 수들의 합 or 연속된 구간의 길이 or 연속된 구간 내 최대/최소값 등  <br>
  - 구간을 좌우로 확장 및 축소해가면서 조건을 체크할 수 있는지? 
     : 조건을 초과하면 앞쪽을 잘라서 다시 조건을 만족시킬 수 있는지? <br>
  - 매번 전체를 계산하는게 아닌, 누적값을 구할 수 있나? 윈도우 이동 시 계산을 빠르게 할 수 있나? 
  - 조건을 만족하는 최대/최소 길이 or 합을 구하라는 문제인지? 
  - 완전탐색을 할 경우 n이 10만 이상이라 터질 때, 혹시 슬라이딩 윈도우를 사용해서 이를 해결할 수 있는가? 
<br>

#### 슬라이딩 윈도우 로직 
1. `left`, `right` 포인터를 사용해 현재 윈도우 정의한다. (배열 안에서 현재 탐색 중인 구간의 시작과 끝)
    ```cpp
    int right = 0, left = 0;
    ```
    <br>

2. `right` 하나씩 늘리며 새로운 과일을 윈도우에 추가한다. 
    ```cpp
    while (right < n) { 
      ...

      right++;
    }
    ```
    <br>

3. 새로운 과일이 들어왔을 때 `count[과일번호]`를 증가시키고, 처음 들어온 종류면 (`count[fruits[right]] == 0` 이면) `kcnt` 도 함께 증가시킨다. 
    ```cpp
    if (count[fruits[right]] == 0) {
      kcnt++; 
    }
    count[fruits[right]]++; 
    ```
    <br>

4. 과일 종류 수가 2를 초과하면, `left`를 이동해 윈도우에서 과일 제거하고, 그 과일 개수가 0이되면 (`count[fruits[left]] == 0` 이면) `kcnt` 를 1 감소해서 업데이트 한다. 
    ```cpp
    while (kcnt > 2) {
      count[fruits[left]]--; // 우선 왼쪽끝의 과일 종류수 카운트를 1 줄이고 
      
      if (count[fruits[left]] == 0) {
          kcnt--; // 만약에 삭제 후 더 이상 없을 때 kcnt 업데이트하고 
      }

      left++; // 그러고나서 옮겨야지. 그래야 옮기기 이전의 값이 줄여지니까 
    }
    ```
    <br>


5. 현재 윈도우 길이 `right - left + 1` 과 현재 `answer` 비교해서 최대값 갱신

<br>

#### 구현 중 실수
- count설정과 `left++` 순서 <br>
  : 과일 제거 전에 `left++`를 하게되면 윈도우에서 아직 제거되지 않은 과일이 빠진다. 항상 값 변경 후, 인덱스를 이동하도록 순서 유지할 것!! 

<br><br><br>



### [IOIOI 문제 접근](https://www.acmicpc.net/problem/5525)
[풀이](https://github.com/lenamin/Algorithm-Archive/commit/492c52b4dab974143db1c19f119897ce4e5282b8)
- 첫 번쨰 풀이 (substr 활용) <br>
  : `substr` 이용해서 target 크기만큼 잘라서 비교했음. `substr`의 경우 복사를 하기 때문에 문제의 절반 조건을 통과하지만, 일부 테케에서는 시간초과가 떠서 50점밖에 나오지 않았음. 
  ```cpp
  for (int i = 0; i <= m - 2 * n; i++) {
    if (target == s.substr(i, 2 * n + 1)) {
        cnt++;
    }
  }
  ``` 

- 슬라이딩 윈도우 활용 
  - 슬라이딩 윈도우 : 일정한 범위를 유지하면서 포인터를 이동해 문제를 해결하는 방식 
  - 이 문제에서의 윈도우는 : 패턴 시작점에서 "OI" 쌍이 몇 번 반복되었는지 세고, 
  - 그 연속된 "OI" 개수가 n보다 같거나 커지면 일치하니까 상태변수 증가시킴 

- **예외처리**
  - 겹치는 패턴 또한 고려해야 했음 
  - 기존 그냥 슬라이딩 윈도우를 구현할 경우, 이미 관찰한 부분은 지나가버리기 때문에 패턴이 겹치는 경우는 탐색하지 못함 
  - while 문 종료 후에 마지막 'I'를 살려서 탐색 계속함 
    ```cpp
    if (cnt > 0) { 겹치는 'I' 때문에 i -= 1; } <- 되돌려놓는것!! >
    ```
    : 이 부분이 핵심이었다. 겹치는 부분을 어떻게 처리할지 몰라서 substr 썼던 거였는데, 되돌림으로써 재활용할 수 있는 것이었음! 
    : 대놓고 슬라이딩 윈도우 문제 아닌 것 같아도 슬라이딩 윈도우를 응용할 수 있는 문제였음 - * 
 <br><br>