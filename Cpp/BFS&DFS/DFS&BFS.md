# BFS & DFS 


### [BFS를 활용해 치즈 녹이는 문제](https://www.acmicpc.net/status?user_id=julieeee&problem_id=2636&from_mine=1) 정리 

#### 이 문제에서 BFS를 사용해야 하는 이유 
- 외부 공기 탐색 : (0, 0)에서 시작해 외부 공기만 다라가며 치즈를 찾아야 한다 
- 내부 공기를 무시해야 하기 때문 : DFS는 경로 추적이 어려워 내부 공기와 혼동하기 쉽다 
- 동시 녹이기 구현 : BFS 로 탐색해서 치즈를 한 번에 녹이면 시간 흐름 표현이 쉽다 (while 한바퀴가 한시간)

#### 로직 
1. 입력 처리 (배열, visited 준비)
2. while (치즈가 남아있을 때까지 반복):
    1. 현재 치즈 개수 세기 → lastCC에 저장
    2. visited 초기화
    3. cheese 목록 초기화
    4. BFS(0,0) → 외부공기 따라가며 치즈 후보 수집
    5. 수집된 치즈들을 arr에서 0으로 녹임
    6. 시간(hour) 증가
3. 결과 출력: 총 시간, 마지막 치즈 수

#### 실수들 
- vector<vector<T>> 에는 `fill()`을 사용할 수 없음 
    -> 일일이 그냥 이중 for 문 돌려야 함 

<br><br>

### DFS를 통해 싸이클 여부 판별할 때 
- 이미 방문한 정점에 다시 도달하는지 확인해야하는게 맞지만, 단순하게 그냥 방문한 적 있고 && 같은 정점 인 조건만으로 검색하면 안됨 !! (백트랙킹 했을 때 그냥 지나가는건데 싸이클로 판별할 수도 있다)
- 그래서 어떻게? <br>
바로 이전 위치에서 다시 오는 것은 싸이클이 아닌 것 <br>
→ px, py (이전 좌표) 사용해서 이전좌표에서 오는 건지, 다른 좌표에서 오는 건지 구분해서 판단한다

  ```cpp
  if (dot == board[nx][ny]) {
      if (visited[nx][ny] && !(nx == px && ny == py)) {
          isCycle = true; // 싸이클 발견
          return;
      }
      if (!visited[nx][ny]) {
          dfs(nx, ny, x, y); // 다음 위치로 이동
      }
  }
  ```

<br><br>

### 방향 회전 및 후진 처리 
- 방향은 0 : 북, 1: 동, 2: 남, 3: 서로 표현함 
- 배열 인덱스 순서로 방향 이동 관리! (dx, dy) 

#### 1. 왼쪽 회전 (반시계 방향으로 한 칸 이동할 때)
- 현재 방향이 d 라고 한다면 왼쪽방향은 `(d + 3) % 4` 
- -1 쓰는 대신 + 3 % 4 를 사용해서 음수 인덱스를 방지함! 
<br>
#### 2. 후진 
- 현재 방향이 d 라고 한다면, 후진은 (d + 2) % 4 -> 반대방향으로 두 칸 이동하니까 후진이 되는 것 ! 


<br><br>

### 전역변수로 depth를 관리할 떄의 위험성 
**static 남발하지 말기**
- dfs를 수행할 때 마다 depth를 1씩 증가하는 것을 트래킹하기 위해 depth 변수를 전역으로 선언하고 사용했더니, 각 dfs 에서 독립적인 depth 값을 가지지 못해 정확한 값을 가지지 못했다.
- dfs 함수의 매개변수로 depth를 보내어 관리하도록 하는 것이 안전하다.

**백트래킹**
- 백트래킹에서 가장 중요한 것은 만족하지 않을 때, 다시 이전으로 돌아가기 위해 방문했던 `visited` 를 초기화 해줘야 한다는 것이다!!!
  : 처음에 이걸 이해 못했다가 한참 헤맸다,,

### BFS, DFS 처럼 순회 순서가 중요한 경우 
- list 자료구조를 사용하게 되면 순서를 보장하지 않는다.
- 그래서 DFS, BFS를 호출하기 전에 정렬을 해주는게 필요하다.
  ```cpp
    for (int i = 1; i < vertex + 1; i++) {
    graph[i].sort();
  }
  ```

<br><br>

### 방향벡터 
- 네 방향
  ```cpp
  const int dy[] = {-1, 0, 1, 0};
  const int dx[] = {0, 1, 0, -1};
  ```
- 대각선 방향 포함한 여덟방향
  ```cpp
  int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};
  int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};
  ```

<br><br>

### 미로찾기 문제에서 실수한 부분들 
1. 경계값 조건 줄 때 bfs 함수의 매개변수로 받는 것과 cin으로 입력받은 배열 크기를 동일한 변수를 써버려서 경계값 검사가 정확하지 않았음 / 변수 이름에 주의하기
2. 문제 조건을 잘 보자. 붙여서 입력한다고 했으니 하나의 문자로 받아서 각 문자를 다시 배열에 넣어야했다.
   ```cpp
    for (int i = 0; i < n; i++) {
      string temp;
      cin >> temp;
      for (int j = 0; j < m; j++) {
        numbers[i][j] = temp[j] - '0';
      }
    }    
   ```


   ### Connected Components 문제에서 카운트 시점과 사소한 실수들
#### 더 이상 연결요소가 없어서 for문으로 돌아왔을 때, dfs를 호출하기 전에 카운트를 증가시킨다. 

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (a[i][j] <= k) { 
            f[i][j] = 1; // 1이면 잠긴다 // 0이면 안잠기는 것

            if (visited[i][j] == 0) {
                cnt++;
                dfs(i, j);
            }
        }
    }
}
```

#### 만약 각 연결요소의 수를 카운트 하고 싶다면 (ex. 2667 단지번호 붙이기 문제) 
visited[y][x]를 방문처리 할 때 마다 증가시키면 된다. 

```cpp
void dfs(int y, int x) {
    cnt += 1;
    visited[y][x] = 1; // 현재 노드 방문처리 

    // 이제 (ny, nx) 계산해서 하나씩 주변에 있는지 체크해서 방문할 것 
    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if (visited[ny][nx] == 1) continue;
        if (arr[ny][nx] == 0) continue;
        
        dfs(ny, nx);
    }
}
```